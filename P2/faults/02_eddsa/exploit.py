#!/usr/bin/env python3

import subprocess
import os
import sys
import os.path
import filecmp

from Cryptodome.Util.number import inverse
from hashlib import sha512

q = 2**252 + 27742317777372353535851937790883648493

def H(a):
    return sha512(a).digest()

#converts a number in [0, q-1] to a byte-array representation
def ZtoBytes(z):
    return z.to_bytes(32, byteorder='little')

#converts a byte array back to a number in [0, q-1]
def bytesToZ(inbytes):
    m = int.from_bytes(inbytes, byteorder='little')
    return m % q

def getSig(message, fault=False):
    if fault:
        command = ['./simulator']
    else:
        command = ['./eddsa']
    command += [message]
    sigprog = subprocess.Popen(command, bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid)
    stdout, stderr = sigprog.communicate(timeout=300)
    outlen = 32*2*2 + len(message)*2
    sig = bytes.fromhex(stdout[:outlen].decode('utf-8'))
    R = sig[:32]
    s = sig[32:64]
    message = sig[64:]
    return (R, s, message)

def check_challenge(fname):
    fnames = fname+'_solution'
    if os.path.isfile(fnames):
        if (not os.path.isfile(fname)) and os.access(fnames, os.R_OK):
            print('Challenge failed!')
            return

        with open(fnames, 'rb') as f:
            s = bytesToZ(f.read())

        with open(fname, 'rb') as f:
            r = bytesToZ(f.read())

        if r == s:
            print('Challenge solved!')
        else:
            print('Challenge failed!')

def main():
    with open("key.pub", "rb") as f:
        pkbytes = f.read()

    #the recovered private key, stored as number mod q
    a = 0

########################################################################
# enter your code here

    # you can call the signature program by using getSig()
    #  the parameter "fault" controls if you run the program in the fault simulator or bare (without any faulting)
    inmessage = "This is a message that I want to sign"
    (Rbytes, sbytes, outmessagebytes) = getSig(inmessage, fault=False) # no faulting

    # the above method returns byte arrays. For converting them to numbers mod q, use bytesToZ(). For the other direction, use ZtoBytes()
    s = bytesToZ(sbytes)

    # the hash function SHA512, which is used in the signature scheme, is available via H()
    shash = H(sbytes)

    # if you need to compute a modular inverse, simply call the included inverse()
    sinverse = inverse(s, q)

    # ...
    (Rbytes2, sbytes2, outmessagebytes2) = getSig(inmessage, fault=True)
    s2 = bytesToZ(sbytes2)
    s1 = bytesToZ(sbytes)
    shash2 = H(sbytes2)
    H1 = H( Rbytes + pkbytes+outmessagebytes)
    H2 = H(Rbytes2+pkbytes + outmessagebytes2)

    a =((s1-s2)*inverse(bytesToZ(H1) - bytesToZ(H2),q)) %q
    a=int(a)
	

########################################################################

    abytes = ZtoBytes(a)
    with open('a', 'wb') as f:
        f.write(abytes)

    check_challenge('a')


if __name__ == "__main__":
    sys.exit(main())
